{
  "hash": "8c46530dd2d1031a5bda0839402b3d2a",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Compositional Data Analysis\"\nformat: html\nengine: knitr\n---\n\n::: {.cell}\n<style type=\"text/css\">\np {\n  text-align: justify\n}\n</style>\n:::\n\n\n\n\nThis chapter covers Compositional Data Analysis (CoDA) in DataSHIELD using the `dsCoda` package, which is essential for analyzing time-use data, nutrient compositions, and other proportional data.\n\n## Overview\n\n### What is Compositional Data?\n\nCompositional data consists of parts that sum to a constant (e.g., 100% or 24 hours). Examples include:\n\n- **Time-use data**: Sleep, sedentary time, light activity, moderate-to-vigorous activity\n- **Nutrient composition**: Protein, fat, carbohydrates\n- **Microbiome data**: Relative abundances of bacterial taxa\n- **Body composition**: Fat mass, lean mass, bone mass\n\n### Why Special Methods?\n\nStandard statistical methods assume independence between variables. However, compositional parts are inherently dependentâ€”if one increases, others must decrease. CoDA uses log-ratio transformations to handle this constraint properly.\n\n## CoDA Concepts\n\n### The Simplex\n\nCompositional data lives in a constrained space called the simplex:\n\n$$\\mathcal{S}^D = \\left\\{ \\mathbf{x} = (x_1, \\ldots, x_D) : x_i > 0, \\sum_{i=1}^D x_i = \\kappa \\right\\}$$\n\nwhere $\\kappa$ is the constant sum (e.g., 24 hours for daily time-use).\n\n### Log-Ratio Transformations\n\nThree main transformations move compositional data from the simplex to unconstrained Euclidean space:\n\n1. **ALR** (Additive Log-Ratio): Simple but asymmetric\n2. **CLR** (Centered Log-Ratio): Symmetric but singular\n3. **ILR** (Isometric Log-Ratio): Optimal for regression - **used in ProPASS**\n\n### The ILR Transformation\n\nThe ILR transformation maps D-part compositional data to (D-1) dimensional Euclidean space:\n\n$$\\mathbf{z} = \\log(\\mathbf{x}) \\cdot \\mathbf{V}$$\n\nwhere $\\mathbf{V}$ is an orthonormal basis matrix constructed from a Sequential Binary Partition (SBP).\n\n## Setup\n\n::: {.callout-important}\n## Package Requirements\nCoDA analysis requires the `dsCoda` server-side package. Install the client package from GitHub.\n:::\n\n### Installing dsCodaClient\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Install from GitHub\ndevtools::install_github(\"datashield/dsCodaClient\")\n```\n:::\n\n\n\n\n### Loading Libraries and Connecting\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load required packages\nlibrary(DSI)\nlibrary(DSOpal)\nlibrary(dsBaseClient)\nlibrary(dsTidyverseClient)\nlibrary(dsCodaClient)\n\n# Connect to ProPASS data\nbuilder <- DSI::newDSLoginBuilder()\nbuilder$append(\n  server = \"study1\",\n  url = \"https://opal-demo.obiba.org\",\n  user = \"administrator\",\n  password = \"password\",\n  table = \"ProPass.df\",\n  profile = \"margin-idiom\"\n)\n\nlogindata <- builder$build()\nconns <- datashield.login(logins = logindata, assign = TRUE, symbol = \"D\")\n```\n:::\n\n\n\n\n### Exploring the Data\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Check data structure\nds.colnames(\"D\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$study1\n [1] \"ID\"                       \"vpa\"                     \n [3] \"mpa\"                      \"lpa\"                     \n [5] \"stand\"                    \"sb\"                      \n [7] \"sleep\"                    \"wear_total\"              \n [9] \"age\"                      \"sex\"                     \n[11] \"smoke\"                    \"fruit\"                   \n[13] \"veg\"                      \"edu\"                     \n[15] \"eth\"                      \"job\"                     \n[17] \"slf-hlth\"                 \"alc\"                     \n[19] \"mobility\"                 \"fasting\"                 \n[21] \"med_lipid\"                \"med_bp\"                  \n[23] \"med_glucose\"              \"prev_cvd\"                \n[25] \"prev_ht\"                  \"prev_bronchitis\"         \n[27] \"body_fat_percent\"         \"hdl\"                     \n[29] \"total_cholesterol\"        \"hba1c\"                   \n[31] \"cprotein\"                 \"IGF\"                     \n[33] \"triglycerides\"            \"wc\"                      \n[35] \"bmi\"                      \"t2d\"                     \n[37] \"sbp\"                      \"dbp\"                     \n[39] \"cohort\"                   \"condition\"               \n[41] \"condition_competing_risk\" \"condition_fup\"           \n```\n\n\n:::\n\n```{.r .cell-code}\nds.dim(\"D\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$`dimensions of D in study1`\n[1] 537  42\n\n$`dimensions of D in combined studies`\n[1] 537  42\n```\n\n\n:::\n:::\n\n\n\n\n## The ProPASS CoDA Workflow\n\nThe complete workflow for compositional data analysis follows these steps:\n\n1. **Data Wrangling**: Combine activity categories and select compositional parts\n2. **Handle Zeros**: Use `ds.lrEM()` to impute zeros below detection limits\n3. **Create Composition**: Use `ds.acomp()` to create compositional objects\n4. **Build Basis Matrix**: Use `build_sequential_ilr_V()` for ILR transformation\n5. **Apply ILR**: Use `ds.ilr()` to transform to Euclidean space\n6. **Combine with Covariates**: Merge ILR coordinates with outcome and covariate data\n7. **Survival Analysis**: Fit Fine-Gray competing risks model with ILR coordinates\n\n### Step 1: Data Wrangling\n\nFirst, prepare the compositional parts. In ProPASS, light intensity physical activity (`lipa`) is created by combining `lpa` and `stand`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create combined light activity variable (lipa = lpa + stand)\nds.mutate(\n  df.name = \"D\",\n  tidy_expr = list(lipa = lpa + stand),\n  newobj = \"D2\"\n)\n\n# Select the 5 compositional parts for analysis\n# Order matters for ILR interpretation!\nds.select(\n  df.name = \"D2\",\n  tidy_expr = list(vpa, mpa, lipa, sleep, sb),\n  newobj = \"D3\"\n)\n\n# Check the composition\nds.colnames(\"D3\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$study1\n[1] \"vpa\"   \"mpa\"   \"lipa\"  \"sleep\" \"sb\"   \n```\n\n\n:::\n\n```{.r .cell-code}\nds.dim(\"D3\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$`dimensions of D3 in study1`\n[1] 537   5\n\n$`dimensions of D3 in combined studies`\n[1] 537   5\n```\n\n\n:::\n:::\n\n\n\n\n::: {.callout-note}\n## Composition Parts\nThe 5-part composition represents daily time-use:\n- **vpa**: Vigorous physical activity\n- **mpa**: Moderate physical activity  \n- **lipa**: Light intensity physical activity (lpa + stand)\n- **sleep**: Sleep time\n- **sb**: Sedentary behavior\n:::\n\n### Step 2: Handle Zeros with ds.lrEM()\n\nCompositional data requires all parts > 0. The `ds.lrEM()` function uses log-ratio Expectation-Maximization to impute zeros and values below detection limits:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Impute zeros using log-ratio EM algorithm\nds.lrEM(\n  X = \"D3\",\n  label = 0,                                         # Value indicating zeros/missing\n  dl = c(0.1667, 0.1667, 0.1667, 0.1667, 0.1667),    # Detection limits (10 min = 0.1667 hours)\n  objectname = \"D4\"\n)\n```\n:::\n\n\n\n\n::: {.callout-tip}\n## Understanding ds.lrEM() Parameters\n\n- **X**: Data frame containing compositional parts\n- **label**: Value that indicates zeros/missing (typically 0)\n- **dl**: Detection limits for each part (minimum detectable value)\n- **objectname**: Name for the output object\n\nThe detection limit of 0.1667 hours = 10 minutes represents the minimum meaningful activity bout.\n:::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Verify the imputation\nds.class(\"D4\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$study1\n[1] \"data.frame\"\n```\n\n\n:::\n\n```{.r .cell-code}\nds.dim(\"D4\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$`dimensions of D4 in study1`\n[1] 537   5\n\n$`dimensions of D4 in combined studies`\n[1] 537   5\n```\n\n\n:::\n:::\n\n\n\n\n### Step 3: Create Compositional Object with ds.acomp()\n\nThe `ds.acomp()` function creates an `acomp` class object that properly represents compositional data:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create acomp object\nds.acomp(\n  X = \"D4\",\n  objectname = \"D5\"\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Verify the acomp object\nds.class(\"D5\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$study1\n[1] \"acomp\"\n```\n\n\n:::\n:::\n\n\n\n\n::: {.callout-note}\n## What is an acomp object?\nThe `acomp` class (from the `compositions` R package) represents closed compositions where parts sum to a total. It enables proper compositional operations and transformations.\n:::\n\n### Step 4: Build the ILR Basis Matrix\n\nThe ILR transformation requires a basis matrix V. The `build_sequential_ilr_V()` function creates a sequential binary partition:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get the number of compositional parts\nn_parts <- ds.dim(\"D5\")[[1]][2]\ncat(\"Number of compositional parts:\", n_parts, \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNumber of compositional parts: 5 \n```\n\n\n:::\n\n```{.r .cell-code}\n# Build the sequential ILR basis matrix\nV <- build_sequential_ilr_V(n_parts)\n\n# View the basis matrix\nprint(V)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           ilr1       ilr2       ilr3       ilr4\n[1,]  0.8944272  0.0000000  0.0000000  0.0000000\n[2,] -0.2236068  0.8660254  0.0000000  0.0000000\n[3,] -0.2236068 -0.2886751  0.8164966  0.0000000\n[4,] -0.2236068 -0.2886751 -0.4082483  0.7071068\n[5,] -0.2236068 -0.2886751 -0.4082483 -0.7071068\n```\n\n\n:::\n:::\n\n\n\n\n::: {.callout-note}\n## Understanding the Basis Matrix\nThe basis matrix V defines how parts are contrasted in the ILR transformation:\n\n- **Rows**: Original compositional parts (D parts)\n- **Columns**: ILR coordinates (D-1 coordinates)\n- **Values**: Weights for the log-ratio contrasts\n\nFor 5 parts, you get 4 ILR coordinates.\n:::\n\n### Step 5: Apply ILR Transformation with ds.ilr()\n\nApply the ILR transformation to convert the composition to unconstrained Euclidean coordinates:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Apply ILR transformation\nds.ilr(\n  X = \"D5\",\n  V = V,\n  objectname = \"ilr_coords\"\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Check the result\nds.class(\"ilr_coords\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$study1\n[1] \"rmult\"\n```\n\n\n:::\n\n```{.r .cell-code}\nds.dim(\"ilr_coords\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$`dimensions of ilr_coords in study1`\n[1] 537   4\n\n$`dimensions of ilr_coords in combined studies`\n[1] 537   4\n```\n\n\n:::\n:::\n\n\n\n\nThe ILR transformation creates D-1 = 4 coordinates from the 5-part composition.\n\n### Step 6: Combine with Covariates for Analysis\n\nTo perform survival analysis, combine the ILR coordinates with outcome and covariate data:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load survival analysis package\nlibrary(dsSurvivalClient)\n\n# Merge ILR coordinates back with original data\nds.dataFrame(\n  x = c(\"D2\", \"ilr_coords\"),\n  newobj = \"analysis_data\"\n)\n\n# Convert covariates to appropriate types\nds.asFactor(input.var.name = \"analysis_data$sex\", newobj.name = \"sex_factor\")\nds.asNumeric(x.name = \"analysis_data$age\", newobj = \"age_num\")\nds.asFactor(input.var.name = \"analysis_data$condition_competing_risk\", newobj.name = \"event_factor\")\nds.asNumeric(x.name = \"analysis_data$condition_fup\", newobj = \"fup_num\")\n\n# Combine into final analysis dataset\nds.dataFrame(\n  x = c(\"analysis_data\", \"sex_factor\", \"age_num\", \"event_factor\", \"fup_num\"),\n  newobj = \"dat_coda\"\n)\n\n# Rename the ILR coordinate columns to meaningful names\n# Based on sequential binary partition with order: vpa, mpa, lipa, sleep, sb\nds.rename(\n  df.name = \"dat_coda\",\n  tidy_expr = list(\n    VPAvsAll = `ilr_coords`,        # VPA vs (mpa, lipa, sleep, sb)\n    MPAvsRemaining = `NA.`,         # MPA vs (lipa, sleep, sb)\n    LIPAvsRemaining = `NA..1`,      # LIPA vs (sleep, sb)\n    SLEEPvsSB = `NA..2`             # Sleep vs SB\n  ),\n  newobj = \"dat_coda\"\n)\n\n# Select only the columns needed for survival analysis\n# This avoids issues with variables that have too many missing values\nds.select(\n  df.name = \"dat_coda\",\n  tidy_expr = list(VPAvsAll, MPAvsRemaining, LIPAvsRemaining, SLEEPvsSB, age_num, sex_factor, event_factor, fup_num),\n  newobj = \"dat_coda_clean\"\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Check the analysis data\nds.colnames(\"dat_coda_clean\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$study1\n[1] \"VPAvsAll\"        \"MPAvsRemaining\"  \"LIPAvsRemaining\" \"SLEEPvsSB\"      \n[5] \"age_num\"         \"sex_factor\"      \"event_factor\"    \"fup_num\"        \n```\n\n\n:::\n\n```{.r .cell-code}\nds.dim(\"dat_coda_clean\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$`dimensions of dat_coda_clean in study1`\n[1] 537   8\n\n$`dimensions of dat_coda_clean in combined studies`\n[1] 537   8\n```\n\n\n:::\n:::\n\n\n\n\n### Step 7: Survival Analysis with ILR Coordinates\n\nNow we fit a Fine-Gray competing risks model using the ILR coordinates as exposures:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Setup datadist for rms functions\n# Center ILR coordinates at the compositional mean (geometric center)\nds.datadist(\n  data = \"dat_coda_clean\",\n  adjust_to = list(\n    age_num = \"mean\"\n  )\n)\nds.useDatadist(datadist = \"datadist_dat_coda_clean\")\n\n# Create Fine-Gray object for competing risks analysis\n# etype = \"1\" specifies the event of interest\nds.finegray(\n  formula = \"Surv(fup_num, event_factor) ~ .\",\n  data = \"dat_coda_clean\",\n  etype = \"1\",\n  newobj = \"fg_coda\"\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Fit Cox model on Fine-Gray data with ILR coordinates\n# Each ILR coordinate represents a specific time-use contrast\nds.coxphSLMAassign(\n  formula = \"survival::Surv(fgstart, fgstop, fgstatus) ~ VPAvsAll + MPAvsRemaining + LIPAvsRemaining + SLEEPvsSB + age_num + sex_factor\",\n  dataName = \"fg_coda\",\n  objectname = \"cph_coda\",\n  use.rms = TRUE\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# View model results\nds.coxphSummary(\"cph_coda\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$study1\n                         Low        High      Diff.      Effect       S.E.\nVPAvsAll         -4.06235740 -3.11103842  0.9513190  0.06532509 0.06925808\n Hazard Ratio    -4.06235740 -3.11103842  0.9513190  1.06750600         NA\nMPAvsRemaining   -2.30510945 -1.83498977  0.4701197 -0.13793418 0.11340659\n Hazard Ratio    -2.30510945 -1.83498977  0.4701197  0.87115603         NA\nLIPAvsRemaining  -0.28723712 -0.02656285  0.2606743 -0.26217308 0.10341553\n Hazard Ratio    -0.28723712 -0.02656285  0.2606743  0.76937785         NA\nSLEEPvsSB         0.08593969  0.47208848  0.3861488 -0.09547689 0.12514362\n Hazard Ratio     0.08593969  0.47208848  0.3861488  0.90893937         NA\nage_num          56.00000000 68.00000000 12.0000000  0.17992717 0.10433054\n Hazard Ratio    56.00000000 68.00000000 12.0000000  1.19713017         NA\nsex_factor - 2:1  1.00000000  2.00000000         NA -0.06581742 0.14344655\n Hazard Ratio     1.00000000  2.00000000         NA  0.93630180         NA\n                  Lower 0.95  Upper 0.95 Type\nVPAvsAll         -0.07041825  0.20106843    1\n Hazard Ratio     0.93200393  1.22270844    2\nMPAvsRemaining   -0.36020702  0.08433866    1\n Hazard Ratio     0.69753191  1.08799729    2\nLIPAvsRemaining  -0.46486379 -0.05948237    1\n Hazard Ratio     0.62822067  0.94225214    2\nSLEEPvsSB        -0.34075387  0.14980010    1\n Hazard Ratio     0.71123394  1.16160201    2\nage_num          -0.02455693  0.38441127    1\n Hazard Ratio     0.97574213  1.46874936    2\nsex_factor - 2:1 -0.34696749  0.21533264    1\n Hazard Ratio     0.70682831  1.24027439    2\nattr(,\"heading\")\n[1] \"             Effects              Response : survival::Surv(fgstart, fgstop, fgstatus)\"\nattr(,\"class\")\n[1] \"summary.rms\" \"matrix\"     \nattr(,\"scale\")\n[1] \"log Relative Hazard\" \"Hazard Ratio\"       \nattr(,\"obj.name\")\n[1] \"fit_model\"\nattr(,\"adjust\")\n[1] \"\"\nattr(,\"conf.type\")\n[1] \"z\"\n```\n\n\n:::\n:::\n\n\n\n\n::: {.callout-note}\n## ILR Coordinate Interpretation\nThe ILR coordinates in the Cox model represent log-ratio contrasts based on the sequential binary partition:\n\n| Coordinate | Contrast | Interpretation |\n|------------|----------|----------------|\n| **VPAvsAll** | VPA vs (mpa, lipa, sleep, sb) | Effect of increasing VPA relative to all other activities |\n| **MPAvsRemaining** | MPA vs (lipa, sleep, sb) | Effect of increasing MPA relative to lighter activities |\n| **LIPAvsRemaining** | LIPA vs (sleep, sb) | Effect of increasing LIPA relative to inactive time |\n| **SLEEPvsSB** | Sleep vs SB | Effect of increasing sleep relative to sedentary behavior |\n\nA positive coefficient means higher hazard ratio when that ILR coordinate increases.\n:::\n\n## Basis Rotation\n\nThe order of compositional parts determines the ILR interpretation. **Rotation is simply done by reordering the variables in `ds.select()`** - this changes which component is contrasted first:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# ============================================================\n# ROTATION IS CONTROLLED BY VARIABLE ORDER IN ds.select()\n# ============================================================\n\n# Rotation 1: VPA first (default in ProPASS)\nds.select(df.name = \"D2\", tidy_expr = list(vpa, mpa, lipa, sleep, sb), newobj = \"comp_rot1\")\n\n# Rotation 2: Sleep first (to study sleep effects)\nds.select(df.name = \"D2\", tidy_expr = list(sleep, sb, lipa, mpa, vpa), newobj = \"comp_rot2\")\n\n# Rotation 3: Sedentary behavior first\nds.select(df.name = \"D2\", tidy_expr = list(sb, sleep, lipa, mpa, vpa), newobj = \"comp_rot3\")\n```\n:::\n\n\n\n\nAfter selecting with a different order, apply the same workflow:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example: Sleep-first rotation\nds.select(df.name = \"D2\", tidy_expr = list(sleep, sb, lipa, mpa, vpa), newobj = \"comp_rotated\")\n\n# Same workflow applies - order of dl must match new variable order!\nds.lrEM(\n  X = \"comp_rotated\",\n  label = 0,\n  dl = c(0.1667, 0.1667, 0.1667, 0.1667, 0.1667),\n  objectname = \"comp_rotated_imp\"\n)\n\nds.acomp(X = \"comp_rotated_imp\", objectname = \"comp_rotated_acomp\")\n\n# Build basis and transform (same function, interpretation changes)\nV_rot <- build_sequential_ilr_V(5)\nds.ilr(X = \"comp_rotated_acomp\", V = V_rot, objectname = \"ilr_rotated\")\n```\n:::\n\n\n\n\n::: {.callout-tip}\n## How Rotation Works\nRotation is **not** a separate function - it's simply the order you specify in `ds.select()`:\n\n| Variable Order | First ILR Interprets |\n|----------------|---------------------|\n| `vpa, mpa, lipa, sleep, sb` | VPA vs. all other activities |\n| `sleep, sb, lipa, mpa, vpa` | Sleep vs. all waking activities |\n| `sb, sleep, lipa, mpa, vpa` | Sedentary vs. all other behaviors |\n\n**Strategy**: Put your exposure of interest first to get its specific contrast in `ilr1`.\n:::\n\n## Interpreting CoDA Results\n\n### ILR Coefficient Interpretation\n\nILR coefficients are not directly interpretable in terms of original parts. They represent:\n\n- **ilr1**: Log-ratio contrast between first part and geometric mean of remaining parts\n- **ilr2**: Log-ratio contrast within the remaining parts\n- And so on...\n\n### Isotemporal Substitution\n\nTo understand the effect of reallocating time between activities, use isotemporal substitution analysis. This is typically computed client-side using the ILR coefficients from the model.\n\n## Summary of Key Functions\n\n| Function | Purpose | Input | Output |\n|----------|---------|-------|--------|\n| `ds.lrEM()` | Impute zeros | Data frame with composition | Data frame with imputed values |\n| `ds.acomp()` | Create composition object | Data frame | acomp object |\n| `build_sequential_ilr_V()` | Build basis matrix | Number of parts (integer) | Matrix V |\n| `ds.ilr()` | ILR transformation | acomp object + V matrix | ILR coordinates |\n\n## Best Practices\n\n::: {.callout-tip}\n## CoDA Analysis Tips\n\n1. **Handle zeros properly**: Always use `ds.lrEM()` before transformation - zeros break log-ratios\n2. **Check closure**: Ensure compositional parts sum to expected total (e.g., 24 hours)\n3. **Choose rotation wisely**: Put your exposure of interest first for clearer interpretation\n4. **Set appropriate detection limits**: Use meaningful minimum values (e.g., 10 minutes for activities)\n5. **Report geometric means**: Present compositional means correctly (not arithmetic means)\n:::\n\n\n\n\n\n\n\n\n\n## References\n\n- Dumuid, D. et al. (2018). Compositional data analysis for physical activity, sedentary time and sleep research. *Statistical Methods in Medical Research*.\n- Chastin, S. et al. (2015). Combined effects of time spent in physical activity, sedentary behaviors and sleep on obesity and cardio-metabolic health markers.\n- [compositions R package](https://cran.r-project.org/package=compositions)\n- [zCompositions R package](https://cran.r-project.org/package=zCompositions) (for lrEM algorithm)\n\n## Next Steps\n\nContinue to the next chapter or return to [Survival Analysis](8-survival-analysis.qmd) to combine CoDA with time-to-event outcomes.\n",
    "supporting": [
      "9-coda-analysis_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}